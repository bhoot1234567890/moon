// =============================
// Radial Text Overlay Settings
// =============================
// These factors control the position and size of the radial text overlays relative to the wheel's width.
const TEXT_RADIUS_FACTOR = 0.5;   // Distance from wheel center as a fraction of wheel width
const TEXT_WIDTH_FACTOR  = 0.15;  // Overlay width as a fraction of wheel width
const TEXT_HEIGHT_FACTOR = 0.04;  // Overlay height as a fraction of wheel width
const TEXT_OVERLAY_Z_OFFSET = 0; // Z offset to keep overlays in front of wheel

// =============================
// Animation and State Variables
// =============================
let wheelRef = null; // Reference to wheel object for animation and overlays
let camInitial;
let cameraDirection = 'forward'; // 'forward' or 'backward'
let overlayShouldShow = false;
let wheelRotatingToOriginal = false;
let wheelRotationStart = 0;
let wheelRotationTarget = 0;
let wheelRotationProgress = 0;
let cameraAnimating = false;
let camStart = null;
let camTarget = null;
let textFadeProgress = 0; // 0 = fully transparent, 1 = fully opaque

// Screen state: "start", "main", "overlay"
let currentScreen = "start";

const TEXT_FADE_IN_SPEED = 0.025; // Adjust for slower/faster fade
const MAIN_SCREEN_POS = new THREE.Vector3(0.75, 0, 1); // match camTarget
const MAIN_SCREEN_THRESHOLD = 0.08; // match camera arrival threshold

// Highlighted Mandal index (0-based)
let highlightedMandalIndex = 0;
const HIGHLIGHT_GLOW_COLOR = '#00eaff'; // Tron blue
const HIGHLIGHT_GLOW_SIZE = 1.5; // Larger for neon effect
const HIGHLIGHT_GLOW_OPACITY = 0.85; // More visible

// =============================
// Update Radial Text Overlay Positions and Sizes
// =============================
function updateRadialTextSpriteTransforms() {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  wheelRef.updateMatrixWorld();
  const box = new THREE.Box3().setFromObject(wheelRef);
  const wheelWidth = box.max.x - box.min.x;
  const wheelRadius = wheelWidth / 2;
  // Calculate overlay parameters
  const textRadius = Math.max(wheelRadius * TEXT_RADIUS_FACTOR, 0.5);
  const textWidth  = Math.max(wheelWidth * TEXT_WIDTH_FACTOR, 0.5);
  const textHeight = Math.max(wheelWidth * TEXT_HEIGHT_FACTOR, 0.15);
  const spokeCount = wheelRef.userData.textSprites.length;
  for (let i = 0; i < spokeCount; i++) {
    const initialOffset = Math.PI / 10; // 18 degrees in radians
    const angle = (i / spokeCount) * Math.PI * 2 - initialOffset;
    const x = wheelRef.position.x + Math.cos(angle) * textRadius;
    const y = wheelRef.position.y + Math.sin(angle) * textRadius;
    const z = wheelRef.position.z + TEXT_OVERLAY_Z_OFFSET; // overlays always in front of wheel
    const sprite = wheelRef.userData.textSprites[i];
    sprite.position.set(x, y, z);
    sprite.scale.set(textWidth, textHeight, 1);
    sprite.material.rotation = angle;
  }
  // Always hide overlays on start screen
  if (document.getElementById('overlay')?.style.opacity !== '0.0') {
    hideTextSpritesCompletely();
  }
}
// =============================
// Update Radial Text Overlay Positions and Sizes with Wheel Rotation Offset
// =============================
// =============================
// UI Event Handlers
// =============================
// Escape key: restore camera and overlay
document.addEventListener('keydown', (e) => {
  // ENTER key
  if (e.key === 'Enter') {
    if (currentScreen === 'start') {
      // Go to main screen
      cameraAnimating = true;
      cameraDirection = 'forward';
      camStart = camera.position.clone();
      camTarget = MAIN_SCREEN_POS.clone();
      document.getElementById('overlay').style.opacity = '0.0';
      document.getElementById('overlay').style.pointerEvents = 'none';
      overlayShouldShow = false;
      if (wheelRef) {
        wheelRotatingToOriginal = true;
        wheelRotationStart = wheelRef.rotation.z;
        wheelRotationTarget = wheelRef.userData.initialRotationZ;
        wheelRotationProgress = 0;
        wheelRef.userData.spinning = false;
      }
      setTimeout(() => setTextSpritesVisibility(true), 400);
      currentScreen = 'main';
      return;
    }
    if (currentScreen === 'main') {
      // Open overlay for highlighted Mandal
      showMandalOverlay(highlightedMandalIndex);
      currentScreen = 'overlay';
      return;
    }
    if (currentScreen === 'overlay') {
      // Do nothing
      return;
    }
  }

  // ESCAPE key
  if (e.key === 'Escape') {
    if (currentScreen === 'start') {
      // Do nothing
      return;
    }
    if (currentScreen === 'main') {
      // Go back to start screen
      if (cameraAnimating) return;
      cameraAnimating = true;
      cameraDirection = 'backward';
      camStart = camera.position.clone();
      camTarget = camInitial.clone();
      overlayShouldShow = true;
      if (wheelRef) wheelRef.userData.spinning = true;
      currentScreen = 'start';
      return;
    }
    if (currentScreen === 'overlay') {
      // Close overlay, go back to main screen
      hideMandalOverlay();
      currentScreen = 'main';
      return;
    }
  }

  // Arrow keys: only work on main screen
  if (currentScreen === 'main' && !wheelRotationAnimating) {
    if (e.key === 'ArrowLeft') {
      rotateWheelByStep(+1);
      highlightedMandalIndex = (highlightedMandalIndex + 9) % 10;
      updateHighlightedMandalSprite();
    }
    if (e.key === 'ArrowRight') {
      rotateWheelByStep(-1);
      highlightedMandalIndex = (highlightedMandalIndex + 1) % 10;
      updateHighlightedMandalSprite();
    }
  }
});
// Highlight Mandal Sprite Glow
function updateHighlightedMandalSprite() {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  wheelRef.userData.textSprites.forEach((sprite, idx) => {
    // Remove previous glow sprite if any
    if (sprite.userData.glowSprite) {
      scene.remove(sprite.userData.glowSprite);
      sprite.userData.glowSprite = null;
    }
    if (sprite.userData.innerGlowSprite) {
      scene.remove(sprite.userData.innerGlowSprite);
      sprite.userData.innerGlowSprite = null;
    }
    if (idx === highlightedMandalIndex) {
      // Log highlighted Mandal index
      console.log('Highlighted Mandal:', idx + 1);
      // Add glow sprite behind the highlighted sprite
      const tex = generateRadialTexture(HIGHLIGHT_GLOW_COLOR);
      // Tron-like blue outer glow
      const mat = new THREE.SpriteMaterial({
        map: tex,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: HIGHLIGHT_GLOW_OPACITY
      });
      const glow = new THREE.Sprite(mat);
      glow.scale.set(sprite.scale.x * HIGHLIGHT_GLOW_SIZE, sprite.scale.y * HIGHLIGHT_GLOW_SIZE, 1);
      glow.position.copy(sprite.position);
      glow.material.rotation = sprite.material.rotation;
      glow.renderOrder = sprite.renderOrder - 1;
      glow.visible = sprite.visible;
      scene.add(glow);
      // Optional: add inner neon ring for Tron effect
      const innerTex = generateRadialTexture('#00bfff');
      const innerMat = new THREE.SpriteMaterial({
        map: innerTex,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.45
      });
      const innerGlow = new THREE.Sprite(innerMat);
      innerGlow.scale.set(sprite.scale.x * (HIGHLIGHT_GLOW_SIZE * 0.7), sprite.scale.y * (HIGHLIGHT_GLOW_SIZE * 0.7), 1);
      innerGlow.position.copy(sprite.position);
      innerGlow.material.rotation = sprite.material.rotation;
      innerGlow.renderOrder = sprite.renderOrder - 2;
      innerGlow.visible = sprite.visible;
      scene.add(innerGlow);
      sprite.userData.glowSprite = glow;
      sprite.userData.innerGlowSprite = innerGlow;
    }
  });
}

// Start button: animate camera towards wheel and show overlays
function updateHighlightedGlowInAnimation() {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  const sprite = wheelRef.userData.textSprites[highlightedMandalIndex];
    if (sprite && sprite.userData.glowSprite) {
      const glow = sprite.userData.glowSprite;
      glow.position.copy(sprite.position);
      glow.material.rotation = sprite.material.rotation;
      glow.scale.set(sprite.scale.x * HIGHLIGHT_GLOW_SIZE, sprite.scale.y * HIGHLIGHT_GLOW_SIZE, 1);
      glow.visible = sprite.visible;
    }
    if (sprite && sprite.userData.innerGlowSprite) {
      const innerGlow = sprite.userData.innerGlowSprite;
      innerGlow.position.copy(sprite.position);
      innerGlow.material.rotation = sprite.material.rotation;
      innerGlow.scale.set(sprite.scale.x * (HIGHLIGHT_GLOW_SIZE * 0.7), sprite.scale.y * (HIGHLIGHT_GLOW_SIZE * 0.7), 1);
      innerGlow.visible = sprite.visible;
  }
}
const startBtn = document.getElementById('start-btn');
if (startBtn) {
  startBtn.addEventListener('click', () => {
    if (cameraAnimating) return;
    cameraAnimating = true;
    cameraDirection = 'forward';
    camStart = camera.position.clone();
    camTarget = MAIN_SCREEN_POS.clone();
    document.getElementById('overlay').style.opacity = '0.0';
    document.getElementById('overlay').style.pointerEvents = 'none';
    overlayShouldShow = false;
    if (wheelRef) {
      wheelRotatingToOriginal = true;
      wheelRotationStart = wheelRef.rotation.z;
      wheelRotationTarget = wheelRef.userData.initialRotationZ;
      wheelRotationProgress = 0;
      wheelRef.userData.spinning = false;
    }
    setTimeout(() => setTextSpritesVisibility(true), 400);
    currentScreen = 'main';
  });
}
// Clean starfield + nebula scene
// Uses three from importmap in index.html

import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { KTX2Loader } from 'three/examples/jsm/loaders/KTX2Loader.js';

const app = document.getElementById('app');

// Scene + renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000009);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);


app.appendChild(renderer.domElement);

// Draco and KTX2 loader setup
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');

const ktx2Loader = new KTX2Loader();
ktx2Loader.setTranscoderPath('https://unpkg.com/three@0.159.0/examples/jsm/libs/basis/');
ktx2Loader.detectSupport(renderer);

// GLTF loader setup
const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(dracoLoader);
gltfLoader.setKTX2Loader(ktx2Loader);

// Load and add the golden chariot wheel model
gltfLoader.load(
  'assets/models/golden-chariot-wheel-draco-ktx2.glb',
  (gltf) => {
    const wheel = gltf.scene;
    // Place wheel directly in front of camera
    wheel.position.set(0, 0, 0);
    wheel.scale.set(2.5, 2.5, 2.5);
    // Rotate by 18 degrees around Y axis
    wheel.rotation.set(0, 0, Math.PI / 10);

    // Save initial Z rotation for restoration
    wheel.userData.initialRotationZ = wheel.rotation.z;
    wheel.updateMatrixWorld();
    const box = new THREE.Box3().setFromObject(wheel);
    wheel.userData.cachedWidth = box.max.x - box.min.x;
    wheel.userData.cachedRadius = wheel.userData.cachedWidth / 2;

    // Traverse and update all mesh materials for gilded metallic look (minimal glow)
    wheel.traverse((child) => {
      if (child.isMesh) {
        child.material = new THREE.MeshPhysicalMaterial({
          color: 0xffd700, // gold
          metalness: 1.0,
          roughness: 0.22, // more metallic
          clearcoat: 1.0,
          clearcoatRoughness: 0.09,
          transmission: 0.0,
          emissive: 0x332200, // very subtle dark gold
          emissiveIntensity: 0.08, // almost no glow
          transparent: false,
          opacity: 1.0,
          envMapIntensity: 1.2, // more reflection
        });
      }
    });

    // Enhanced glowing aura: multiple layered sprites with pulsing effect
    const auraLayers = [
      { color: '#ffd700', scale: 4.2, opacity: 0.18 },
      { color: '#fff8b0', scale: 5.6, opacity: 0.11 },
      { color: '#ffe066', scale: 7.1, opacity: 0.07 }
    ];
    wheel.userData.auras = [];
    auraLayers.forEach((layer, idx) => {
      const tex = generateRadialTexture(layer.color);
      const mat = new THREE.SpriteMaterial({
        map: tex,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: layer.opacity
      });
      const aura = new THREE.Sprite(mat);
      aura.scale.set(layer.scale, layer.scale, 1);
      aura.position.set(0, 0, 0);
      wheel.add(aura);
      wheel.userData.auras.push(aura);
    });

    // Start with wheel spinning
    wheel.userData.spinning = true;
    wheelRef = wheel;
    scene.add(wheel);


    // Prepare radial text sprites but hide initially and set opacity 0
    createRadialTextSprites(wheel, [
      'Mandal 1','Mandal 2','Mandal 3','Mandal 4','Mandal 5',
      'Mandal 6','Mandal 7','Mandal 8','Mandal 9','Mandal 10'
    ]);
    hideTextSpritesCompletely();
  setupMandalOverlayAfterWheel();
  highlightedMandalIndex = 0;
  updateHighlightedMandalSprite();
// =============================
// Mandal Detail Overlay Logic
// =============================
// Mandal Detail Overlay Logic
let mandalOverlay = null;
let mandalOverlayVisible = false;
let selectedMandalIndex = null;

function createMandalOverlay() {
  // Create overlay if not exists
  if (document.getElementById('mandal-overlay')) return;
  mandalOverlay = document.createElement('div');
  mandalOverlay.id = 'mandal-overlay';
  mandalOverlay.style.position = 'fixed';
  mandalOverlay.style.top = '0';
  mandalOverlay.style.left = '0';
  mandalOverlay.style.width = '100vw';
  mandalOverlay.style.height = '100vh';
  mandalOverlay.style.background = 'rgba(10,10,30,0.97)';
  mandalOverlay.style.zIndex = '9999';
  mandalOverlay.style.display = 'none';
  mandalOverlay.style.justifyContent = 'center';
  mandalOverlay.style.alignItems = 'center';
  mandalOverlay.style.flexDirection = 'column';
  mandalOverlay.style.color = '#ffd700';
  mandalOverlay.style.fontFamily = 'sans-serif';
  mandalOverlay.style.overflowY = 'auto';
  mandalOverlay.style.padding = '32px';
  mandalOverlay.style.boxSizing = 'border-box';
  mandalOverlay.style.transition = 'opacity 0.3s';
  mandalOverlay.style.opacity = '0';
  mandalOverlay.style.display = 'flex';

  // Close button
  const closeBtn = document.createElement('button');
  closeBtn.innerText = 'Ã—';
  closeBtn.style.position = 'absolute';
  closeBtn.style.top = '32px';
  closeBtn.style.right = '48px';
  closeBtn.style.fontSize = '2.5rem';
  closeBtn.style.background = 'none';
  closeBtn.style.border = 'none';
  closeBtn.style.color = '#ffd700';
  closeBtn.style.cursor = 'pointer';
  closeBtn.style.zIndex = '10001';
  closeBtn.addEventListener('click', hideMandalOverlay);
  mandalOverlay.appendChild(closeBtn);

  // Content container
  const content = document.createElement('div');
  content.id = 'mandal-overlay-content';
  content.style.maxWidth = '600px';
  content.style.width = '100%';
  content.style.background = 'rgba(30,30,60,0.98)';
  content.style.borderRadius = '18px';
  content.style.boxShadow = '0 0 32px #222';
  content.style.padding = '40px 32px 32px 32px';
  content.style.position = 'relative';
  content.style.display = 'flex';
  content.style.flexDirection = 'column';
  content.style.alignItems = 'center';
  mandalOverlay.appendChild(content);

  document.body.appendChild(mandalOverlay);

  // Escape key closes overlay
  document.addEventListener('keydown', (e) => {
    if (mandalOverlayVisible && e.key === 'Escape') {
      hideMandalOverlay();
    }
  });
}

function showMandalOverlay(mandalIndex) {
  createMandalOverlay();
  selectedMandalIndex = mandalIndex;
  mandalOverlayVisible = true;
  const overlay = document.getElementById('mandal-overlay');
  overlay.style.display = 'flex';
  setTimeout(() => { overlay.style.opacity = '1'; }, 10);
  populateMandalOverlay(mandalIndex);
  currentScreen = 'overlay';
}

function hideMandalOverlay() {
  mandalOverlayVisible = false;
  const overlay = document.getElementById('mandal-overlay');
  if (overlay) {
    overlay.style.opacity = '0';
    setTimeout(() => { overlay.style.display = 'none'; }, 300);
  }
  currentScreen = 'main';
}

function populateMandalOverlay(mandalIndex) {
  const content = document.getElementById('mandal-overlay-content');
  if (!content) return;
  // Clear previous content
  content.innerHTML = '';

  // Mandal label
  const mandalLabel = `Mandal ${mandalIndex + 1}`;
  const title = document.createElement('h2');
  title.innerText = mandalLabel;
  title.style.marginBottom = '18px';
  title.style.color = '#ffd700';
  content.appendChild(title);

  // Podcast player
  const podcastSrc = `podcast.mp3`; // Replace with per-mandal if available
  const audio = document.createElement('audio');
  audio.controls = true;
  audio.src = podcastSrc;
  audio.style.width = '100%';
  audio.style.marginBottom = '18px';
  content.appendChild(audio);

  // Collapsible video player
  const videoContainer = document.createElement('div');
  videoContainer.style.width = '100%';
  videoContainer.style.marginBottom = '18px';
  const videoToggle = document.createElement('button');
  videoToggle.innerText = 'Show Video';
  videoToggle.style.background = '#ffd700';
  videoToggle.style.color = '#222';
  videoToggle.style.border = 'none';
  videoToggle.style.padding = '8px 18px';
  videoToggle.style.borderRadius = '8px';
  videoToggle.style.cursor = 'pointer';
  videoToggle.style.marginBottom = '8px';
  videoContainer.appendChild(videoToggle);
  const video = document.createElement('video');
  video.controls = true;
  video.src = '';
  video.style.width = '100%';
  video.style.display = 'none';
  videoContainer.appendChild(video);
  videoToggle.addEventListener('click', () => {
    if (video.style.display === 'none') {
      video.style.display = 'block';
      videoToggle.innerText = 'Hide Video';
      // Set video src if available
      video.src = '';
    } else {
      video.style.display = 'none';
      videoToggle.innerText = 'Show Video';
    }
  });
  content.appendChild(videoContainer);

  // Full text download link
  const textFile = `rigveda/book${mandalIndex+1}.txt`;
  const downloadLink = document.createElement('a');
  downloadLink.href = textFile;
  downloadLink.innerText = 'Download Full Text';
  downloadLink.download = `Mandal${mandalIndex+1}.txt`;
  downloadLink.style.background = '#ffd700';
  downloadLink.style.color = '#222';
  downloadLink.style.padding = '8px 18px';
  downloadLink.style.borderRadius = '8px';
  downloadLink.style.textDecoration = 'none';
  downloadLink.style.marginBottom = '18px';
  content.appendChild(downloadLink);

  // Short description
  const desc = document.createElement('p');
  desc.innerText = getMandalDescription(mandalIndex);
  desc.style.marginTop = '24px';
  desc.style.fontSize = '1.1rem';
  desc.style.color = '#fff8b0';
  content.appendChild(desc);
}

function getMandalDescription(idx) {
  // Replace with real descriptions if available
  const descs = [
    'The first Mandal introduces the Rigveda and contains hymns to Agni, Indra, and other deities.',
    'The second Mandal focuses on hymns dedicated to Agni and Indra, with philosophical themes.',
    'The third Mandal features the famous Gayatri mantra and hymns to Agni, Indra, and Vishvamitra.',
    'The fourth Mandal contains hymns attributed to Vamadeva and praises to Agni and Indra.',
    'The fifth Mandal is known for hymns to the Visvedevas and Maruts, with family connections.',
    'The sixth Mandal includes hymns to Agni, Indra, and the Ashvins, with a focus on prosperity.',
    'The seventh Mandal is attributed to Vasishtha and contains hymns to Varuna and Indra.',
    'The eighth Mandal is diverse, with hymns to various deities and philosophical reflections.',
    'The ninth Mandal is dedicated almost entirely to Soma, the sacred ritual drink.',
    'The tenth Mandal contains philosophical hymns, including the Purusha Sukta and creation hymns.'
  ];
  return descs[idx] || '';
}

// =============================
// Add click event to Mandal text sprites
// =============================
function addMandalSpriteClickEvents() {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  wheelRef.userData.textSprites.forEach((sprite, idx) => {
    sprite.onClick = () => {
      showMandalOverlay(idx);
    };
    // Add pointer cursor
    sprite.cursor = 'pointer';
    // Add event listener for raycaster
    sprite.userData.mandalIndex = idx;
  });
}

// Highlight Mandal Sprite Glow
function updateHighlightedMandalSprite() {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  wheelRef.userData.textSprites.forEach((sprite, idx) => {
    // Remove previous glow sprite if any
    if (sprite.userData.glowSprite) {
      scene.remove(sprite.userData.glowSprite);
      sprite.userData.glowSprite = null;
    }
    if (idx === highlightedMandalIndex) {
      // Add glow sprite behind the highlighted sprite
      const tex = generateRadialTexture(HIGHLIGHT_GLOW_COLOR);
      const mat = new THREE.SpriteMaterial({
        map: tex,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: HIGHLIGHT_GLOW_OPACITY
      });
      const glow = new THREE.Sprite(mat);
      glow.scale.set(sprite.scale.x * HIGHLIGHT_GLOW_SIZE, sprite.scale.y * HIGHLIGHT_GLOW_SIZE, 1);
      glow.position.copy(sprite.position);
      glow.material.rotation = sprite.material.rotation;
      glow.renderOrder = sprite.renderOrder - 1;
      glow.visible = sprite.visible;
      scene.add(glow);
      sprite.userData.glowSprite = glow;
    }
  });
}

// Ensure glow sprite follows visibility and position of highlighted Mandal
function updateHighlightedGlowInAnimation() {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  const sprite = wheelRef.userData.textSprites[highlightedMandalIndex];
  if (sprite && sprite.userData.glowSprite) {
    const glow = sprite.userData.glowSprite;
    glow.position.copy(sprite.position);
    glow.material.rotation = sprite.material.rotation;
    glow.scale.set(sprite.scale.x * HIGHLIGHT_GLOW_SIZE, sprite.scale.y * HIGHLIGHT_GLOW_SIZE, 1);
    glow.visible = sprite.visible;
  }
}

// Raycaster for sprite clicks
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
renderer.domElement.addEventListener('pointerdown', (event) => {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  // Calculate mouse position in normalized device coordinates
  mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
  mouse.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(wheelRef.userData.textSprites);
  if (intersects.length > 0) {
    const sprite = intersects[0].object;
    if (typeof sprite.onClick === 'function') {
      sprite.onClick();
    }
  }
});

// Call after creating text sprites
function setupMandalOverlayAfterWheel() {
  addMandalSpriteClickEvents();
}
  },
  undefined,
  (err) => {
    console.error('Failed to load wheel model:', err);
  }
);

// Camera
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 0, 5);
camInitial = camera.position.clone();

// Bloom composer setup
const renderScene = new RenderPass(scene, camera);
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  0.32, // strength (boosted for Tron glow)
  0.9, // radius
  0.01 // threshold
);
const composer = new EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

// Lighting - subtle fill
scene.add(new THREE.AmbientLight(0xffffff, 0.10));
// Add a soft directional light for metallic highlights
const dirLight = new THREE.DirectionalLight(0xfff8e1, 0.45);
dirLight.position.set(10, 20, 18);
scene.add(dirLight);

// Helper: create a glowing sphere material
function makeGlowMaterial(color, emissive, opacity=0.92, size=1.0) {
  return new THREE.MeshPhysicalMaterial({
    color: color, // base color (dimmer)
    emissive: emissive, // glow color
    emissiveIntensity: 1.2, // toned down glow
    roughness: 0.12,
    metalness: 0.0,
    transmission: 0.0,
    transparent: true,
    opacity: opacity,
    depthWrite: true,
    clearcoat: 0.85,
    clearcoatRoughness: 0.08,
  });
}

// Make star spheres
function makeStarSpheres(count, radiusMin, radiusMax, size, color, emissive) {
  const group = new THREE.Group();
  for (let i = 0; i < count; i++) {
    const r = radiusMin + Math.random() * (radiusMax - radiusMin);
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.sin(phi) * Math.sin(theta);
    const z = r * Math.cos(phi);
    const mat = makeGlowMaterial(color, emissive, 0.92, size);
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(size, 16, 16), mat);
    mesh.position.set(x, y, z);
    mesh.userData.phase = Math.random() * Math.PI * 2;
    group.add(mesh);
  }
  return group;
}

// Use dimmer base color and blue/cyan emission for glow
const farStars = makeStarSpheres(1200, 200, 700, 0.18, 0x223344, 0x7fdfff);
const midStars = makeStarSpheres(700, 60, 300, 0.32, 0x222233, 0x8ecaff);
const nearStars = makeStarSpheres(180, 8, 120, 0.5, 0x333344, 0xffffff);
scene.add(farStars, midStars, nearStars);

// Nebula sprites: generate several large, soft sprites with additive blending
function makeNebula(colorHex, size = 160, depth = 0, opacity = 0.55) {
  const tex = generateRadialTexture(colorHex);
  const mat = new THREE.SpriteMaterial({ map: tex, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity });
  const sp = new THREE.Sprite(mat);
  sp.scale.set(size, size, 1);
  sp.position.set((Math.random() - 0.5) * 160, (Math.random() - 0.5) * 80, depth);
  return sp;
}

// Helper: create a soft radial canvas texture tinted by color
function generateRadialTexture(hex) {
  const size = 512;
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
  const c = new THREE.Color(hex);
  const rgba = (r, g, b, a) => `rgba(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)},${a})`;
  grad.addColorStop(0, rgba(c.r, c.g, c.b, 0.95));
  grad.addColorStop(0.2, rgba(c.r, c.g, c.b, 0.55));
  grad.addColorStop(0.45, rgba(c.r, c.g, c.b, 0.25));
  grad.addColorStop(1, rgba(c.r*0.1, c.g*0.1, c.b*0.1, 0.0));
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,size,size);
  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;
  return tex;
}

// Create layered nebulae with blue, teal, purple hues
const nebulaGroup = new THREE.Group();
nebulaGroup.add(makeNebula('#3fb8a2', 420, -40, 0.5)); // teal
nebulaGroup.add(makeNebula('#6a4fb5', 360, -20, 0.42)); // purple
nebulaGroup.add(makeNebula('#2f6fb6', 520, 0, 0.45)); // blue
nebulaGroup.add(makeNebula('#b569ff', 280, 30, 0.35)); // pink-purple
nebulaGroup.add(makeNebula('#57d9ff', 200, 60, 0.22)); // cyan highlight
scene.add(nebulaGroup);

// Subtle volumetric fog-like plane layers (soft quad with gradient) to add depth
function makeFogPlane(colorHex, width=800, height=200, z=0, opacity=0.06) {
  const tex = generateRadialTexture(colorHex);
  const mat = new THREE.SpriteMaterial({ map: tex, blending: THREE.NormalBlending, transparent: true, opacity, depthWrite: false });
  const sp = new THREE.Sprite(mat);
  sp.scale.set(width, height, 1);
  sp.position.z = z;
  sp.position.x = (Math.random()-0.5)*60;
  sp.position.y = (Math.random()-0.5)*30 + 10;
  return sp;
}

scene.add(makeFogPlane('#2f6fb6', 900, 260, -60, 0.08));
scene.add(makeFogPlane('#6a4fb5', 900, 200, -20, 0.06));
scene.add(makeFogPlane('#3fb8a2', 900, 320, 40, 0.05));

// Gentle global fog
scene.fog = new THREE.FogExp2(0x0a0a1a, 0.008);

let time = 0;


function animate() {
  requestAnimationFrame(animate);
  time += 0.0007; // even slower motion

  // Animate camera if needed
  if (cameraAnimating && camStart && camTarget) {
    const lerpSpeed = 0.08;
    const t = Math.min(1, lerpSpeed + (camStart.distanceTo(camera.position) / camStart.distanceTo(camTarget)) * lerpSpeed);
    camera.position.lerp(camTarget, t);
    if (camera.position.distanceTo(camTarget) < 0.08) {
      camera.position.copy(camTarget);
      cameraAnimating = false;
      if (cameraDirection === 'backward' && overlayShouldShow) {
        const overlay = document.getElementById('overlay');
        if (overlay) {
          overlay.style.opacity = '1.0';
          overlay.style.pointerEvents = 'auto';
        }
        overlayShouldShow = false;
      }
    }
  }

  // Animate star spheres gently (very subtle drift and twinkle)
  [farStars, midStars, nearStars].forEach((starGroup, idx) => {
    starGroup.children.forEach((mesh, i) => {
      const phase = mesh.userData.phase || 0;
      mesh.position.x += Math.sin(time * 0.13 + phase) * 0.0007 * (idx+1);
      mesh.position.y += Math.cos(time * 0.11 + phase) * 0.0007 * (idx+1);
      mesh.material.opacity = 0.85 + 0.12 * Math.sin(time * 0.7 + phase + idx * 1.3);
      mesh.material.emissiveIntensity = 1.0 + 0.4 * Math.sin(time * 0.8 + phase + idx * 1.1);
    });
  });

  // Animate wheel aura (gentle pulsing)
  const wheel = wheelRef;
  if (wheel && wheel.userData.auras) {
    wheel.userData.auras.forEach((aura, idx) => {
      // Pulse opacity and scale for glow effect
      const baseOpacity = [0.18, 0.11, 0.07][idx];
      const baseScale = [4.2, 5.6, 7.1][idx];
      aura.material.opacity = baseOpacity + 0.025 * Math.sin(time * 2.1 + idx * 1.3);
      const scalePulse = 1.0 + 0.02 * Math.sin(time * 1.7 + idx * 1.7);
      aura.scale.set(baseScale * scalePulse, baseScale * scalePulse, 1);
    });
    // Spin wheel slowly if overlay is visible
    if (wheel.userData.spinning) {
      wheel.rotation.z -= 0.0008; // slow spin
    }
    // Ease wheel rotation to original when start is pressed
    if (wheelRotatingToOriginal) {
      wheelRotationProgress += 0.04; // speed of easing
      if (wheelRotationProgress >= 1) {
        wheel.rotation.z = wheelRotationTarget;
        wheelRotatingToOriginal = false;
      } else {
        // Ease out cubic
        const t = wheelRotationProgress;
        const ease = 1 - Math.pow(1-t, 3);
        wheel.rotation.z = wheelRotationStart + (wheelRotationTarget - wheelRotationStart) * ease;
      }
    }
  }

  // slow nebula drift (even slower)
  nebulaGroup.children.forEach((s, idx) => {
    s.position.x += Math.sin(time * 0.12 + idx) * 0.003;
    s.position.y += Math.cos(time * 0.09 + idx * 1.3) * 0.0015;
    s.material.opacity = Math.max(0.12, s.material.opacity * (0.995 + Math.sin(time*0.11 + idx)*0.002));
  });

  // Text fade-in logic
  const camDistToMain = camera.position.distanceTo(MAIN_SCREEN_POS);
  if (camDistToMain < MAIN_SCREEN_THRESHOLD) {
    if (textFadeProgress < 1.0) {
      textFadeProgress += TEXT_FADE_IN_SPEED;
      textFadeProgress = Math.min(1.0, textFadeProgress);
    }
  } else {
    textFadeProgress = 0;
  }
  setTextSpritesVisibilityByFade();

  // Animate wheel rotation for arrow keys
  if (wheelRotationAnimating && wheelRef) {
    wheelRotationAnimProgress += WHEEL_ROTATE_ANIM_SPEED;
    if (wheelRotationAnimProgress >= 1) {
      wheelRef.rotation.z = wheelRotationAnimEnd;
      wheelRotationAnimating = false;
    } else {
      // Ease out cubic
      const t = wheelRotationAnimProgress;
      const ease = 1 - Math.pow(1-t, 3);
      wheelRef.rotation.z = wheelRotationAnimStart + (wheelRotationAnimEnd - wheelRotationAnimStart) * ease;
    }
    // Update text overlays to match wheel rotation
    updateRadialTextSpriteTransformsWithOffset(wheelRef.rotation.z);
  } else if (wheelRef) {
    // Normal update (keep overlays in sync with wheel)
    updateRadialTextSpriteTransformsWithOffset(wheelRef.rotation.z);
  }

  // Update highlighted Mandal glow visibility and position
  updateHighlightedGlowInAnimation();

  composer.render();
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
  bloomPass.setSize(window.innerWidth, window.innerHeight);
});

// =============================
// Create Radial Text Sprites for Wheel
// =============================
function createRadialTextSprites(wheel, labels) {
  // Remove previous text sprites if any
  if (wheel.userData.textSprites) {
    wheel.userData.textSprites.forEach(sprite => scene.remove(sprite));
  }
  wheel.userData.textSprites = [];
  const spokeCount = labels.length;
  wheel.updateMatrixWorld();
  const wheelWorldPos = new THREE.Vector3();
  wheel.getWorldPosition(wheelWorldPos);
  // Use cached width/radius
  const wheelWidth = wheel.userData.cachedWidth;
  const wheelRadius = wheel.userData.cachedRadius;
  // Fallback minimums for overlays
  const minRadius = 0.5;
  const minWidth = 0.5;
  const minHeight = 0.15;
  const textRadius = Math.max(wheelRadius * TEXT_RADIUS_FACTOR, minRadius);
  const textWidth  = Math.max(wheelWidth * TEXT_WIDTH_FACTOR, minWidth);
  const textHeight = Math.max(wheelWidth * TEXT_HEIGHT_FACTOR, minHeight);
  for (let i = 0; i < spokeCount; i++) {
    // Dynamically set canvas resolution based on camera distance
    let canvasWidth = 1024;
    let canvasHeight = 256;
    let fontSize = 112;
    let margin = 64;
    // If camera is close to wheel, use even higher resolution
    if (camera && wheel) {
      const wheelPos = new THREE.Vector3();
      wheel.getWorldPosition(wheelPos);
      const camDist = camera.position.distanceTo(wheelPos);
      if (camDist < 2.5) {
        canvasWidth = 2048;
        canvasHeight = 512;
        fontSize = 224;
        margin = 128;
      }
    }
    // Create canvas and draw text
    const canvas = document.createElement('canvas');
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    const ctx = canvas.getContext('2d');
    ctx.font = `bold ${fontSize}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ffd700';
    ctx.globalAlpha = 1.0;
    ctx.strokeStyle = '#332200';
    ctx.lineWidth = Math.floor(fontSize/14);
    ctx.strokeText(labels[i], margin, canvas.height/2);
    ctx.fillText(labels[i], margin, canvas.height/2);
    // Create Three.js sprite from canvas
    const tex = new THREE.CanvasTexture(canvas);
    tex.needsUpdate = true;
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.NearestFilter;
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(textWidth, textHeight, 1);
    // Position radially around wheel
    const angle = (i / spokeCount) * Math.PI * 2;
    const x = wheelWorldPos.x + Math.cos(angle) * textRadius;
    const y = wheelWorldPos.y + Math.sin(angle) * textRadius;
    const z = wheelWorldPos.z + TEXT_OVERLAY_Z_OFFSET;
    sprite.position.set(x, y, z);
    sprite.center.set(0.5, 0.5);
    sprite.material.rotation = angle;
    sprite.renderOrder = 999;
    sprite.visible = false;
    scene.add(sprite);
    wheel.userData.textSprites.push(sprite);
  }
}

// =============================
// Set Visibility of Radial Text Sprites
// =============================
function setTextSpritesVisibility(visible) {
  if (wheelRef && wheelRef.userData.textSprites) {
    wheelRef.userData.textSprites.forEach(sprite => {
      if (visible) {
        sprite.visible = true;
        sprite.material.opacity = 1.0;
      } else {
        sprite.visible = false;
        sprite.material.opacity = 0.0;
      }
    });
  }
}

function hideTextSpritesCompletely() {
  if (wheelRef && wheelRef.userData.textSprites) {
    wheelRef.userData.textSprites.forEach(sprite => {
      sprite.visible = false;
      sprite.material.opacity = 0.0;
    });
  }
}

function setTextSpritesVisibilityByCamera() {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  const wheelPos = new THREE.Vector3();
  wheelRef.getWorldPosition(wheelPos);
  const camDist = camera.position.distanceTo(wheelPos);
  // Fade range: fully transparent at >=6.0, fully opaque at <=2.0
  const fadeStart = 2.0;
  const fadeEnd = 2.0;
  let opacity = 0.0;
  if (camDist <= fadeEnd) {
    opacity = 1.0;
  } else if (camDist >= fadeStart) {
    opacity = 0.0;
  } else {
    opacity = 1.0 - (camDist - fadeEnd) / (fadeStart - fadeEnd);
    opacity = Math.max(0, Math.min(1, opacity));
  }
  const visible = opacity > 0.01;
  wheelRef.userData.textSprites.forEach(sprite => {
    sprite.visible = visible;
    sprite.material.opacity = opacity;
  });
}

function setTextSpritesVisibilityByFade() {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  wheelRef.userData.textSprites.forEach(sprite => {
    sprite.visible = textFadeProgress > 0.01;
    sprite.material.opacity = textFadeProgress;
  });
}

let wheelTargetRotation = null;
let wheelRotationAnimating = false;
let wheelRotationAnimStart = 0;
let wheelRotationAnimEnd = 0;
let wheelRotationAnimProgress = 0;
const WHEEL_ROTATE_STEP = Math.PI * 2 / 10; // 36 degrees in radians
const WHEEL_ROTATE_ANIM_SPEED = 0.08; // Adjust for faster/slower animation

function rotateWheelByStep(direction) {
  if (!wheelRef) return;
  if (wheelRotationAnimating) return;
  wheelRotationAnimStart = wheelRef.rotation.z;
  wheelRotationAnimEnd = wheelRef.rotation.z + direction * WHEEL_ROTATE_STEP;
  wheelRotationAnimProgress = 0;
  wheelRotationAnimating = true;
}

function updateRadialTextSpriteTransformsWithOffset(offsetAngle = 0) {
  if (!wheelRef || !wheelRef.userData.textSprites) return;
  const wheelWidth = wheelRef.userData.cachedWidth;
  const wheelRadius = wheelRef.userData.cachedRadius;
  const textRadius = Math.max(wheelRadius * TEXT_RADIUS_FACTOR, 0.5);
  const textWidth  = Math.max(wheelWidth * TEXT_WIDTH_FACTOR, 0.5);
  const textHeight = Math.max(wheelWidth * TEXT_HEIGHT_FACTOR, 0.15);
  const spokeCount = wheelRef.userData.textSprites.length;
  for (let i = 0; i < spokeCount; i++) {
    const initialOffset = Math.PI / 10; // 18 degrees in radians
    const angle = (i / spokeCount) * Math.PI * 2 + offsetAngle - initialOffset;
    const x = wheelRef.position.x + Math.cos(angle) * textRadius;
    const y = wheelRef.position.y + Math.sin(angle) * textRadius;
    const z = wheelRef.position.z + TEXT_OVERLAY_Z_OFFSET;
    const sprite = wheelRef.userData.textSprites[i];
    sprite.position.set(x, y, z);
    sprite.scale.set(textWidth, textHeight, 1);
    sprite.material.rotation = angle;
  }
}

animate();

